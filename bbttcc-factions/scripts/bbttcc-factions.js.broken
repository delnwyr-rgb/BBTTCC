/**
 * BBTTCC Factions Module v4.8.1-ENHANCED
 * Fully compliant with FoundryVTT v13+ patterns based on research of working modules
 * Uses modern async/await, proper error handling, and current API patterns
 */

// Import with validation - will be null if import fails
import { FactionSheet } from './faction-sheet.js';
import { FactionActor } from './faction-actor.js';

// Make FactionSheet globally available immediately after import
console.log('BBTTCC Factions | FactionSheet imported:', typeof FactionSheet !== 'undefined');
if (typeof FactionSheet !== 'undefined') {
    window.FactionSheet = FactionSheet;
    console.log('BBTTCC Factions | FactionSheet made globally available');
} else {
    console.error('BBTTCC Factions | CRITICAL: FactionSheet import failed!');
}

// Default Organization Points structure
const DEFAULT_OPS_STRUCTURE = {
    violence: { value: 0, max: 10 },
    nonlethal: { value: 0, max: 10 },
    intrigue: { value: 0, max: 10 },
    economy: { value: 0, max: 10 },
    softpower: { value: 0, max: 10 },
    diplomacy: { value: 0, max: 10 }
};

/**
 * Modern module class with proper async/await patterns and enhanced functionality
 * @class BBTTCCFactionsModule
 * @version 4.8.1-ENHANCED
 */
class BBTTCCFactionsModule {
    static MODULE_ID = 'bbttcc-factions';
    static VERSION = '4.8.1-ENHANCED';
    static api = null;
    static initialized = false;
    static hookIds = []; // Store hook IDs for proper cleanup
    static #instance = null; // Singleton pattern
    
    /**
     * Initialize the module with modern patterns
     */
    static async initialize() {
        if (this.initialized) {
            console.warn(`${this.MODULE_ID} | Already initialized, skipping...`);
            return;
        }
        
        console.log(`${this.MODULE_ID} | Initializing with modern FoundryVTT v13+ and D&D5e v5.4+ patterns...`);
        
        // D&D5e v5.4 compatibility note
        if (game.system.id === 'dnd5e') {
            const version = game.system.version;
            if (foundry.utils.isNewerVersion(version, "5.4.0")) {
                console.log(`${this.MODULE_ID} | Running on D&D5e v${version} - fully compatible`);
            } else if (foundry.utils.isNewerVersion(version, "5.0.0")) {
                console.warn(`${this.MODULE_ID} | Running on D&D5e v${version} - compatible but may show deprecation warnings. v5.4+ recommended.`);
            } else {
                console.warn(`${this.MODULE_ID} | Running on D&D5e v${version} - outdated, may have compatibility issues.`);
            }
        }
        
        try {
            // Setup components in proper order - but delay sheets until ready
            await this.setupSettings();
            this.setupHooks();
            this.createAPI();
            
            this.initialized = true;
            
            // Double-check sheet registration after everything is initialized
            setTimeout(() => {
                console.log(`${this.MODULE_ID} | Post-init sheet registration check...`);
                if (CONFIG?.Actor?.sheetClasses?.npc) {
                    console.log(`${this.MODULE_ID} | Available NPC sheets (post-init):`, Object.keys(CONFIG.Actor.sheetClasses.npc));
                    const possibleKeys = ["bbttcc-factions.FactionSheet", "FactionSheet", "bbttcc-factions"];
                    for (const key of possibleKeys) {
                        const registered = !!CONFIG.Actor.sheetClasses.npc[key];
                        console.log(`${this.MODULE_ID} | Post-init sheet key "${key}" registered:`, registered);
                        if (registered && !this.registeredSheetKey) {
                            this.registeredSheetKey = key;
                            console.log(`${this.MODULE_ID} | ✓ Updated registered sheet key to: "${key}"`);
                        }
                    }
                } else {
                    console.warn(`${this.MODULE_ID} | CONFIG.Actor.sheetClasses.npc still not available post-init`);
                }
            }, 1000);
            
            console.log(`${this.MODULE_ID} | Initialization completed successfully`);
            
            // Notify other modules
            Hooks.callAll(`${this.MODULE_ID}.ready`, this.api);
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Failed to initialize:`, error);
            ui.notifications.error('BBTTCC Factions failed to initialize. Check console for details.');
            throw error;
        }
    }
    
    /**
     * Modern compatibility check
     */
    static async checkCompatibility() {
        const issues = [];
        
        // FoundryVTT version check
        if (!foundry.utils.isNewerVersion(game.version, "13.0")) {
            issues.push(`FoundryVTT v13.0+ required, found: ${game.version}`);
        }
        
        // System check
        if (game.system.id !== 'dnd5e') {
            issues.push(`D&D 5e system required, found: ${game.system.id}`);
        }
        
        // Check D&D5e version - v5.4+ preferred but v5.0+ supported with deprecation warnings
        if (!foundry.utils.isNewerVersion(game.system.version, "5.0.0")) {
            issues.push(`D&D 5e v5.0.0+ required, found: ${game.system.version}`);
        } else if (!foundry.utils.isNewerVersion(game.system.version, "5.4.0")) {
            console.warn(`${this.MODULE_ID} | D&D 5e v5.4.0+ recommended for best compatibility, found: ${game.system.version}. May show deprecation warnings.`);
        }
        
        if (issues.length > 0) {
            throw new Error(`Compatibility issues: ${issues.join(', ')}`);
        }
    }
    
    /**
     * Modern settings registration with proper error handling
     */
    static async setupSettings() {
        try {
            game.settings.register(this.MODULE_ID, 'enableMacroIntegration', {
                name: 'BBTTCC.Settings.EnableMacroIntegration.Name',
                hint: 'BBTTCC.Settings.EnableMacroIntegration.Hint',
                scope: 'world',
                config: true,
                type: Boolean,
                default: true,
                onChange: value => {
                    console.log(`${this.MODULE_ID} | Macro integration ${value ? 'enabled' : 'disabled'}`);
                }
            });
            
            game.settings.register(this.MODULE_ID, 'debugMode', {
                name: 'BBTTCC.Settings.DebugMode.Name',
                hint: 'BBTTCC.Settings.DebugMode.Hint',
                scope: 'world',
                config: true,
                type: Boolean,
                default: false,
                onChange: value => {
                    console.log(`${this.MODULE_ID} | Debug mode ${value ? 'enabled' : 'disabled'}`);
                }
            });
            
            console.log(`${this.MODULE_ID} | Settings registered successfully`);
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Failed to setup settings:`, error);
            throw error;
        }
    }
    
    /**
     * Modern hook setup with proper error handling and cleanup tracking
     */
    static setupHooks() {
        try {
            // Store hook IDs for cleanup
            this.hookIds.push(
                Hooks.on('preCreateActor', this.onPreCreateActor.bind(this)),
                Hooks.on('createActor', this.onCreateActor.bind(this))
            );
            
            console.log(`${this.MODULE_ID} | Hooks registered successfully`);
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Failed to setup hooks:`, error);
            throw error;
        }
    }
    
    /**
     * Modern sheet registration using correct FoundryVTT v13+ patterns
     */
    static registerSheets() {
        try {
            console.log(`${this.MODULE_ID} | Starting sheet registration...`);
            console.log(`${this.MODULE_ID} | FactionSheet class:`, FactionSheet);
            console.log(`${this.MODULE_ID} | FactionSheet name:`, FactionSheet?.name);
            console.log(`${this.MODULE_ID} | DocumentSheetConfig available:`, !!foundry.applications.apps.DocumentSheetConfig);
            console.log(`${this.MODULE_ID} | registerSheet method available:`, typeof foundry.applications.apps.DocumentSheetConfig.registerSheet);
            
            // Register the sheet
            foundry.applications.apps.DocumentSheetConfig.registerSheet(Actor, "bbttcc-factions", FactionSheet, {
                types: ["npc"],
                makeDefault: false,
                label: "BBTTCC Faction Sheet"
            });
            
            console.log(`${this.MODULE_ID} | Sheet registration completed - checking registration...`);
            
            // Try to verify registration worked by checking CONFIG
            console.log(`${this.MODULE_ID} | CONFIG available:`, !!CONFIG);
            console.log(`${this.MODULE_ID} | CONFIG.Actor available:`, !!CONFIG?.Actor);
            console.log(`${this.MODULE_ID} | CONFIG.Actor.sheetClasses available:`, !!CONFIG?.Actor?.sheetClasses);
            console.log(`${this.MODULE_ID} | CONFIG.Actor.sheetClasses.npc available:`, !!CONFIG?.Actor?.sheetClasses?.npc);
            
            if (CONFIG?.Actor?.sheetClasses?.npc) {
                console.log(`${this.MODULE_ID} | Available NPC sheets:`, Object.keys(CONFIG.Actor.sheetClasses.npc));
                
                // Check multiple possible registration keys
                const possibleKeys = [
                    "bbttcc-factions.FactionSheet",
                    "FactionSheet", 
                    "bbttcc-factions"
                ];
                
                for (const key of possibleKeys) {
                    const registered = !!CONFIG.Actor.sheetClasses.npc[key];
                    console.log(`${this.MODULE_ID} | Sheet key "${key}" registered:`, registered);
                    if (registered) {
                        console.log(`${this.MODULE_ID} | ✓ Found sheet with key: "${key}"`);
                        console.log(`${this.MODULE_ID} | Sheet class:`, CONFIG.Actor.sheetClasses.npc[key]);
                        
                        // Update sheetClass format based on what's actually registered
                        this.registeredSheetKey = key;
                    }
                }
            }
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | CRITICAL: Sheet registration failed:`, error);
            console.error(`${this.MODULE_ID} | This will prevent custom faction sheets from appearing`);
            // Don't throw - allow module to continue but with clear error
        }
    }
    
    /**
     * Create modern API with proper async patterns and enhanced functionality
     */
    static createAPI() {
        this.api = {
            // Core functionality
            factions: {
                create: createFactionModern,
                get: this.getFactionData.bind(this),
                update: this.updateFactionOPs.bind(this),
                validate: this.validateFaction.bind(this),
                repair: this.validateAndRepair.bind(this),
                list: this.listFactions.bind(this),
                export: this.exportFactionData.bind(this)
            },
            
            // Events system for other modules
            events: {
                subscribe: (event, callback) => {
                    const hookId = Hooks.on(`${this.MODULE_ID}.${event}`, callback);
                    return () => Hooks.off(hookId);
                },
                emit: (event, data) => {
                    Hooks.callAll(`${this.MODULE_ID}.${event}`, data);
                    // Also emit to BBTTCC namespace for cross-module communication
                    Hooks.callAll(`bbttcc.${event}`, { module: 'factions', ...data });
                }
            },
            
            // Utility functions
            utils: {
                calculatePowerLevel: this.calculatePowerLevel.bind(this),
                generateFactionName: this.generateFactionName.bind(this),
                safeExecute: this.safeExecute.bind(this)
            },
            
            // Configuration
            config: {
                getDefaultOPs: () => foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE),
                getSupportedTypes: () => ['violence', 'nonlethal', 'intrigue', 'economy', 'softpower', 'diplomacy'],
                getPowerLevels: () => ['Emerging', 'Growing', 'Established', 'Powerful', 'Dominant']
            },
            
            // Sheet classes (for advanced usage)
            sheets: {
                // Classes (conditionally available based on import success)
                ...(typeof FactionSheet !== 'undefined' ? { FactionSheet } : {}),
                ...(typeof FactionActor !== 'undefined' ? { FactionActor } : {}),
            },
            
            // Data structures
            DEFAULT_OPS_STRUCTURE: DEFAULT_OPS_STRUCTURE,
            
            // Legacy methods for backward compatibility
            createFaction: createFactionModern,
            getFactionData: this.getFactionData.bind(this),
            updateFactionOPs: this.updateFactionOPs.bind(this),
            waitForReady: this.waitForReady.bind(this),
            validateFaction: this.validateFaction.bind(this),
            
            // Module info and diagnostics
            version: this.VERSION,
            apiVersion: '1.0',
            moduleId: this.MODULE_ID,
            isReady: () => this.initialized,
            runDiagnostics: this.runDiagnostics.bind(this)
        };
        
        // Log available classes for debugging
        console.log(`${this.MODULE_ID} | Exposing API with available classes:`, {
            FactionSheet: typeof FactionSheet !== 'undefined',
            FactionActor: typeof FactionActor !== 'undefined'
        });
        
        // Modern API exposure via game.modules pattern
        const module = game.modules.get(this.MODULE_ID);
        if (module) {
            module.api = this.api;
            console.log(`${this.MODULE_ID} | API exposed via game.modules.get("${this.MODULE_ID}").api`);
        }
        
        // Enhanced global API exposure for cross-module compatibility
        if (!globalThis.BBTTCC) globalThis.BBTTCC = {};
        globalThis.BBTTCC.Factions = this.api;
        
        // Legacy compatibility (maintain existing patterns)
        window.BBTTCCFactions = {
            createFaction: createFactionModern,
            waitForReady: this.waitForReady.bind(this),
            version: this.VERSION
        };
        window.BBTTCC = window.BBTTCC || {};
        window.BBTTCC.Factions = this.api;
        
        // Add global diagnostic command
        window.bbttccFactionsTest = this.runDiagnostics.bind(this);
    }
    
    /**
     * Modern preCreateActor hook with proper async handling
     */
    static async onPreCreateActor(document, data, options, userId) {
        try {
            const isFaction = this.detectFaction(data);
            
            if (isFaction) {
                console.log(`${this.MODULE_ID} | Pre-creating faction with modern patterns`);
                
                // Set faction flags (safe approach)
                if (!data.flags) data.flags = {};
                
                data.flags[this.MODULE_ID] = {
                    isFaction: true,
                    version: '4.8.1-ENHANCED',
                    createdAt: new Date().toISOString(),
                    createdBy: game.user.id,
                    ops: foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE),
                    warLog: [],
                    territories: [],
                    bases: []
                };
                
                // Set sheet assignment - use the confirmed working key format
                if (!data.flags.core) data.flags.core = {};
                const sheetKey = "bbttcc-factions.FactionSheet";  // This is confirmed to work
                data.flags.core.sheetClass = sheetKey;
                console.log(`${this.MODULE_ID} | Setting sheet class to: "${sheetKey}"`);
                
                console.log(`${this.MODULE_ID} | Faction flags prepared successfully`);
            }
        } catch (error) {
            console.error(`${this.MODULE_ID} | Error in onPreCreateActor:`, error);
        }
    }
    
    /**
     * Modern createActor hook with proper async handling
     */
    static async onCreateActor(actor, options, userId) {
        try {
            if (actor.flags?.[this.MODULE_ID]?.isFaction) {
                console.log(`${this.MODULE_ID} | Faction created, performing verification`);
                
                // Verify OPs structure exists in flags
                const ops = actor.getFlag(this.MODULE_ID, 'ops');
                if (!ops || Object.keys(ops).length === 0) {
                    console.warn(`${this.MODULE_ID} | OPs missing, fixing...`);
                    await actor.setFlag(this.MODULE_ID, 'ops', foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE));
                    console.log(`${this.MODULE_ID} | OPs structure added via setFlag`);
                }
                
                // Success notification removed - handled by createFactionModern function
                console.log(`${this.MODULE_ID} | Faction "${actor.name}" creation verified via hook`);
                
                // Emit integration events using our new event system
                if (this.api?.events) {
                    this.api.events.emit('factionCreated', {
                        actor,
                        userId,
                        timestamp: Date.now()
                    });
                }
                
                // Legacy event for backward compatibility
                Hooks.callAll(`${this.MODULE_ID}.created`, {
                    actor: actor,
                    timestamp: Date.now(),
                    userId: userId
                });
            }
        } catch (error) {
            console.error(`${this.MODULE_ID} | Error in onCreateActor:`, error);
        }
    }
    
    /**
     * Enhanced faction detection with multiple criteria
     */
    static detectFaction(data) {
        return data.name?.toLowerCase().includes('faction') || 
               data.flags?.[this.MODULE_ID]?.isFaction ||
               (data.type === 'npc' && data.system?.details?.type?.value === 'faction');
    }
    
    /**
     * Modern waitForReady with proper timeout handling
     */
    static async waitForReady(timeout = 10000) {
        return new Promise((resolve, reject) => {
            if (this.initialized && this.api) {
                return resolve(this.api);
            }
            
            const timeoutId = setTimeout(() => {
                reject(new Error(`${this.MODULE_ID} API not ready within ${timeout}ms`));
            }, timeout);
            
            const hookId = Hooks.once(`${this.MODULE_ID}.ready`, (api) => {
                clearTimeout(timeoutId);
                resolve(api);
            });
        });
    }
    
    /**
     * Get faction data with safe flag access
     */
    static async getFactionData(actor) {
        try {
            if (!actor || !actor.getFlag(this.MODULE_ID, 'isFaction')) {
                throw new Error('Actor is not a valid BBTTCC faction');
            }
            
            return {
                ops: actor.getFlag(this.MODULE_ID, 'ops') || {},
                flags: actor.flags[this.MODULE_ID] || {},
                warLog: actor.getFlag(this.MODULE_ID, 'warLog') || [],
                territories: actor.getFlag(this.MODULE_ID, 'territories') || [],
                bases: actor.getFlag(this.MODULE_ID, 'bases') || []
            };
        } catch (error) {
            console.error(`${this.MODULE_ID} | Error getting faction data:`, error);
            throw error;
        }
    }
    
    /**
     * Update faction OPs with proper validation
     */
    static async updateFactionOPs(actor, opType, value) {
        try {
            if (!actor.getFlag(this.MODULE_ID, 'isFaction')) {
                throw new Error('Actor is not a faction');
            }
            
            const currentOps = actor.getFlag(this.MODULE_ID, 'ops') || {};
            if (!currentOps[opType]) {
                throw new Error(`Invalid OP type: ${opType}`);
            }
            
            const newOps = foundry.utils.deepClone(currentOps);
            newOps[opType].value = Math.max(0, Math.min(newOps[opType].max, value));
            
            await actor.setFlag(this.MODULE_ID, 'ops', newOps);
            return newOps[opType];
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Error updating faction OPs:`, error);
            throw error;
        }
    }
    
    /**
     * Validate faction structure
     */
    static validateFaction(actor) {
        try {
            if (!actor) return false;
            if (!actor.getFlag(this.MODULE_ID, 'isFaction')) return false;
            
            const ops = actor.getFlag(this.MODULE_ID, 'ops');
            if (!ops) return false;
            
            const requiredOPs = Object.keys(DEFAULT_OPS_STRUCTURE);
            return requiredOPs.every(op => ops[op] && typeof ops[op].value === 'number');
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Error validating faction:`, error);
            return false;
        }
    }
    
    /**
     * Safe execution wrapper with fallback
     * @param {Function} operation - Operation to execute
     * @param {*} fallback - Fallback value if operation fails
     * @returns {*} Result or fallback
     */
    static async safeExecute(operation, fallback = null) {
        try {
            return await operation();
        } catch (error) {
            console.error(`${this.MODULE_ID} | Safe execution failed:`, error);
            ui.notifications.warn(`Operation failed, using fallback behavior`);
            return fallback;
        }
    }
    
    /**
     * Enhanced validation and auto-repair mechanism
     * @param {Actor} actor - Actor to validate and repair
     * @returns {Promise<boolean>} True if valid or successfully repaired
     */
    static async validateAndRepair(actor) {
        const issues = [];
        const moduleId = this.MODULE_ID;
        
        try {
            if (!actor.getFlag(moduleId, 'isFaction')) {
                issues.push('Missing faction flag');
                await actor.setFlag(moduleId, 'isFaction', true);
            }
            
            const ops = actor.getFlag(moduleId, 'ops');
            if (!ops || Object.keys(ops).length === 0) {
                issues.push('Missing OPs structure');
                await actor.setFlag(moduleId, 'ops', foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE));
            } else {
                // Check for missing OP types
                const currentOps = foundry.utils.deepClone(ops);
                let needsUpdate = false;
                
                for (const [opType, defaultValue] of Object.entries(DEFAULT_OPS_STRUCTURE)) {
                    if (!currentOps[opType]) {
                        issues.push(`Missing OP type: ${opType}`);
                        currentOps[opType] = defaultValue;
                        needsUpdate = true;
                    }
                }
                
                if (needsUpdate) {
                    await actor.setFlag(moduleId, 'ops', currentOps);
                }
            }
            
            // Check other required arrays
            const arrays = ['warLog', 'territories', 'bases'];
            for (const arrayName of arrays) {
                if (!Array.isArray(actor.getFlag(moduleId, arrayName))) {
                    issues.push(`Missing ${arrayName} array`);
                    await actor.setFlag(moduleId, arrayName, []);
                }
            }
            
            if (issues.length > 0) {
                console.log(`${moduleId} | Repaired ${issues.length} issues for ${actor.name}`);
                ui.notifications.info(`Faction ${actor.name} data repaired automatically`);
            }
            
            return true;
            
        } catch (error) {
            console.error(`${moduleId} | Validation/repair failed:`, error);
            return false;
        }
    }
    
    /**
     * Calculate power level based on total OPs
     * @param {number} totalOPs - Total organization points
     * @returns {string} Power level
     */
    static calculatePowerLevel(totalOPs) {
        if (totalOPs < 10) return "Emerging";
        if (totalOPs < 25) return "Growing";
        if (totalOPs < 40) return "Established";
        if (totalOPs < 55) return "Powerful";
        return "Dominant";
    }
    
    /**
     * Generate faction name suggestions
     * @param {string} theme - Theme for name generation ('military', 'trade', 'tech', etc.)
     * @returns {string[]} Array of suggested names
     */
    static generateFactionName(theme = 'general') {
        const themes = {
            military: ['Iron Legion', 'Steel Guard', 'Crimson Battalion', 'Shadow Regiment'],
            trade: ['Commerce Guild', 'Trade Consortium', 'Merchant Alliance', 'Trading Company'],
            tech: ['Tech Syndicate', 'Data Collective', 'Cyber Guild', 'Innovation Institute'],
            religious: ['Sacred Order', 'Divine Council', 'Faith Assembly', 'Holy Brotherhood'],
            general: ['New Republic', 'United Coalition', 'Free Alliance', 'Commonwealth']
        };
        
        return themes[theme] || themes.general;
    }
    
    /**
     * List all factions in the world
     * @returns {Actor[]} Array of faction actors
     */
    static listFactions() {
        return game.actors.filter(actor => actor.getFlag(this.MODULE_ID, 'isFaction'));
    }
    
    /**
     * Export faction data for backup/migration
     * @param {Actor} actor - Faction to export
     * @returns {Object} Exportable faction data
     */
    static exportFactionData(actor) {
        const moduleId = this.MODULE_ID;
        return {
            name: actor.name,
            type: actor.type,
            img: actor.img,
            flags: actor.flags[moduleId] || {},
            system: {
                details: actor.system?.details || {},
                biography: actor.system?.details?.biography || {}
            },
            exportedAt: new Date().toISOString(),
            exportedBy: game.user.id,
            version: this.VERSION
        };
    }
    
    /**
     * Run comprehensive diagnostics
     * @returns {Promise<Object>} Diagnostic results
     */
    static async runDiagnostics() {
        const results = {
            timestamp: new Date().toISOString(),
            version: this.VERSION,
            moduleId: this.MODULE_ID,
            tests: []
        };
        
        // Test 1: Core functionality
        try {
            const testFaction = await this.safeExecute(async () => {
                return await createFactionModern({
                    name: `Test Faction ${Date.now()}`
                });
            });
            
            if (testFaction) {
                await this.updateFactionOPs(testFaction, 'violence', 5);
                const isValid = this.validateFaction(testFaction);
                await testFaction.delete();
                
                results.tests.push({
                    name: 'Core Functionality',
                    passed: isValid,
                    details: 'Created, updated, and validated test faction'
                });
            } else {
                results.tests.push({
                    name: 'Core Functionality',
                    passed: false,
                    details: 'Failed to create test faction'
                });
            }
        } catch (error) {
            results.tests.push({
                name: 'Core Functionality',
                passed: false,
                error: error.message
            });
        }
        
        // Test 2: API availability
        const apiTest = {
            name: 'API Availability',
            passed: !!(window.BBTTCC?.Factions && game.modules.get(this.MODULE_ID)?.api),
            details: 'API exposed via multiple methods'
        };
        results.tests.push(apiTest);
        
        // Test 3: Existing factions validation
        const factions = this.listFactions();
        const validationResults = await Promise.all(
            factions.map(faction => this.validateFaction(faction))
        );
        
        results.tests.push({
            name: 'Existing Factions Validation',
            passed: validationResults.every(result => result),
            details: `${validationResults.filter(r => r).length}/${factions.length} factions valid`
        });
        
        console.log(`${this.MODULE_ID} | Diagnostics completed:`, results);
        return results;
    }
    
    /**
     * Initialize the integrated GUI system
     */
    static initializeGUISystem() {
        console.log(`${this.MODULE_ID} | Initializing integrated GUI system...`);
        
        // Define GUI classes directly in this script to ensure they load
        window.BBTTCCGUI = {
            // Perfect Character Creation with Tikkun Sparks Guidance
            PerfectCharacterCreation: class extends foundry.applications.api.ApplicationV2 {
                static DEFAULT_OPTIONS = {
                    id: "bbttcc-perfect-character-creation",
                    classes: ["bbttcc-gui"],
                    tag: "div",
                    window: { 
                        title: "BBTTCC Perfect Character Creation",
                        resizable: true 
                    },
                    position: { width: 1000, height: 800 },
                    actions: {
                        selectRace: function(event) { this._onSelectRace(event); },
                        selectClass: function(event) { this._onSelectClass(event); },
                        selectFaction: function(event) { this._onSelectFaction(event); },
                        toggleCategory: function(event) { this._onToggleCategory(event); },
                        createCharacter: function(event) { this._onCreateCharacter(event); }
                    }
                };

                constructor() {
                    super();
                    this.selectedRace = null;
                    this.selectedClass = null;
                    this.selectedFaction = null;
                    this.expandedCategories = new Set();
                    this.selectedItems = new Map();
                    this.bbttccItems = this.getBBTTCCItems();
                }

                getBBTTCCItems() {
                    const items = [];
                    game.packs.forEach(pack => {
                        if (pack.metadata.type === 'Item') {
                            pack.index.forEach(item => {
                                if (item.name.includes('Archetype:') || 
                                    item.name.includes('Crew Type:') || 
                                    item.name.includes('Disadvantage:') ||
                                    item.name.includes('Background:')) {
                                    items.push({
                                        ...item,
                                        packName: pack.metadata.id,
                                        category: this.getItemCategory(item.name)
                                    });
                                }
                            });
                        }
                    });
                    return items;
                }

                getItemCategory(name) {
                    if (name.includes('Archetype:')) return 'Archetypes';
                    if (name.includes('Crew Type:')) return 'Crew Types';
                    if (name.includes('Disadvantage:')) return 'Disadvantages';
                    if (name.includes('Background:')) return 'Backgrounds';
                    return 'Other';
                }

                async _renderHTML(context, options) {
                    const factions = game.actors.filter(a => a.getFlag("bbttcc-factions", "isFaction"));
                    
                    return `
                        <div class="bbttcc-character-creation" style="padding: 20px; height: 100%; overflow-y: auto;">
                            <div class="creation-sections" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 100%;">
                                <div class="core-setup" style="display: flex; flex-direction: column; gap: 15px;">
                                    <h2 style="color: #6f42c1; margin-bottom: 15px;">🎯 Core Character Setup</h2>
                                    
                                    <div class="race-selection">
                                        <label style="font-weight: bold; color: #6f42c1;">Race:</label>
                                        <select id="race-select" data-action="selectRace" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="">Choose a race...</option>
                                            ${CONFIG.DND5E.races ? Object.entries(CONFIG.DND5E.races).map(([key, race]) => 
                                                \`<option value="\${key}">\${race.label || race}</option>\`
                                            ).join('') : ''}
                                        </select>
                                    </div>

                                    <div class="class-selection">
                                        <label style="font-weight: bold; color: #6f42c1;">Class:</label>
                                        <select id="class-select" data-action="selectClass" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="">Choose a class...</option>
                                            ${Object.entries(CONFIG.DND5E.classes).map(([key, cls]) => 
                                                \`<option value="\${key}">\${cls.label}</option>\`
                                            ).join('')}
                                        </select>
                                    </div>

                                    <div class="faction-selection">
                                        <label style="font-weight: bold; color: #6f42c1;">Faction Affiliation:</label>
                                        <select id="faction-select" data-action="selectFaction" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="">Choose a faction...</option>
                                            ${factions.map(faction => 
                                                \`<option value="\${faction.id}">\${faction.name}</option>\`
                                            ).join('')}
                                        </select>
                                    </div>

                                    <div class="tikkun-guidance" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 8px; color: white; margin-top: 20px;">
                                        <h3 style="margin: 0 0 10px 0;">✨ Tikkun Sparks Guidance</h3>
                                        <div style="font-style: italic; line-height: 1.4;">
                                            Welcome to BBTTCC character creation! Select a race and class to receive personalized guidance.
                                        </div>
                                    </div>

                                    <button data-action="createCharacter" style="
                                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                        color: white; 
                                        border: none; 
                                        padding: 15px 25px; 
                                        font-size: 16px; 
                                        font-weight: bold; 
                                        border-radius: 8px; 
                                        cursor: pointer;
                                        margin-top: auto;
                                    ">🧙 Create BBTTCC Character</button>
                                </div>
                                <div class="bbttcc-options" style="display: flex; flex-direction: column; gap: 15px;">
                                    <h2 style="color: #6f42c1; margin-bottom: 15px;">⚔️ BBTTCC Character Options</h2>
                                    <p style="font-style: italic; color: #666;">Character options will be loaded here...</p>
                                </div>
                            </div>
                        </div>
                    `;
                }

                _onSelectRace(event) {
                    this.selectedRace = event.target.value;
                    this.render();
                }

                _onSelectClass(event) {
                    this.selectedClass = event.target.value;
                    this.render();
                }

                _onSelectFaction(event) {
                    this.selectedFaction = event.target.value ? game.actors.get(event.target.value) : null;
                }

                _onToggleCategory(event) {
                    // Category toggle logic here
                }

                async _onCreateCharacter(event) {
                    if (!this.selectedRace || !this.selectedClass) {
                        ui.notifications.warn("Please select both race and class!");
                        return;
                    }

                    try {
                        const actor = await Actor.create({
                            name: \`New BBTTCC Character\`,
                            type: "character",
                            system: {
                                details: {
                                    race: this.selectedRace,
                                    class: this.selectedClass
                                }
                            }
                        });

                        if (this.selectedFaction) {
                            await actor.setFlag("bbttcc-territory", "faction", this.selectedFaction.name);
                            await actor.setFlag("bbttcc-territory", "factionId", this.selectedFaction.id);
                        }

                        ui.notifications.success(\`🧙 Created BBTTCC character: \${actor.name}!\`);
                        actor.sheet.render(true);
                        this.close();

                    } catch (error) {
                        console.error("Character creation failed:", error);
                        ui.notifications.error(\`Character creation failed: \${error.message}\`);
                    }
                }

                async _replaceHTML(content, element, options) {
                    element.innerHTML = content;
                }
            },
            
            // Quick access methods
            openCharacterCreation() {
                new this.PerfectCharacterCreation().render(true);
            },
            
            openDashboard() {
                ui.notifications.info("Dashboard functionality integrated - use existing dashboard!");
            },
            
            // Faction creation method  
            FactionCreation: {
                createFaction() {
                    new Dialog({
                        title: "Create BBTTCC Faction",
                        content: \`
                            <div style="padding: 15px;">
                                <label style="font-weight: bold; color: #6f42c1;">Faction Name:</label>
                                <input type="text" id="faction-name" placeholder="Enter faction name..." 
                                       style="width: 100%; margin-top: 5px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" maxlength="50">
                            </div>
                        \`,
                        buttons: {
                            create: {
                                label: "Create",
                                callback: async (html) => {
                                    const name = html.find('#faction-name').val()?.trim();
                                    if (!name || name.length < 2) {
                                        ui.notifications.warn("Please enter a valid faction name!");
                                        return;
                                    }
                                    
                                    try {
                                        if (window.BBTTCC?.Factions?.factions?.create) {
                                            const faction = await window.BBTTCC.Factions.factions.create({ name });
                                            if (faction) {
                                                ui.notifications.success(\`🏛️ Created faction: \${name}\`);
                                                faction.sheet.render(true);
                                            }
                                        } else {
                                            throw new Error("BBTTCC Factions API not available");
                                        }
                                    } catch (error) {
                                        console.error("Faction creation failed:", error);
                                        ui.notifications.error(\`Failed to create faction: \${error.message}\`);
                                    }
                                }
                            },
                            cancel: {
                                label: "Cancel"
                            }
                        },
                        default: "create"
                    }).render(true);
                }
            }
        };
        
        console.log(`${this.MODULE_ID} | ✅ Integrated GUI system initialized successfully`);
    }
    
    /**
     * Setup persistent GUI buttons that survive game restarts
     */
    static setupPersistentGUI() {
        try {
            console.log(`${this.MODULE_ID} | Setting up persistent GUI buttons...`);
            
            // Add BBTTCC Character Creation button to Actor Directory
            const actorDirectory = ui.actors;
            if (actorDirectory && actorDirectory._element) {
                // Remove any existing buttons first
                actorDirectory._element.find('.bbttcc-persistent-buttons').remove();
                
                // Add button container
                const buttonContainer = $(`
                    <div class="bbttcc-persistent-buttons" style="
                        padding: 8px; 
                        border-top: 1px solid #ccc; 
                        background: #f8f9fa;
                        display: flex;
                        gap: 8px;
                        flex-wrap: wrap;
                    ">
                        <button class="bbttcc-char-btn persistent-bbttcc-btn" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                            color: white; 
                            border: none; 
                            padding: 6px 12px; 
                            border-radius: 4px; 
                            font-size: 12px; 
                            cursor: pointer;
                            flex: 1;
                        ">🧙 BBTTCC Character</button>
                        
                        <button class="bbttcc-faction-btn persistent-faction-btn" style="
                            background: linear-gradient(135deg, #28a745 0%, #20c997 100%); 
                            color: white; 
                            border: none; 
                            padding: 6px 12px; 
                            border-radius: 4px; 
                            font-size: 12px; 
                            cursor: pointer;
                            flex: 1;
                        ">🏛️ Create Faction</button>
                    </div>
                `);
                
                actorDirectory._element.find('.directory-footer').before(buttonContainer);
                
                // Add event listeners
                buttonContainer.find('.bbttcc-char-btn').on('click', (e) => {
                    e.preventDefault();
                    if (window.BBTTCCGUI?.openCharacterCreation) {
                        window.BBTTCCGUI.openCharacterCreation();
                    } else {
                        ui.notifications.error("BBTTCC GUI system not loaded!");
                    }
                });
                
                buttonContainer.find('.bbttcc-faction-btn').on('click', (e) => {
                    e.preventDefault();
                    if (window.BBTTCCGUI?.FactionCreation?.createFaction) {
                        window.BBTTCCGUI.FactionCreation.createFaction();
                    } else {
                        ui.notifications.error("BBTTCC GUI system not loaded!");
                    }
                });
                
                console.log(`${this.MODULE_ID} | Added persistent buttons to Actor Directory`);
            }
            
            // Add Dashboard button via Scene Controls hook (safer approach)
            Hooks.on('getSceneControlButtons', (controls) => {
                try {
                    // Find or create BBTTCC control group
                    let bbttccControl = controls.find(c => c.name === 'bbttcc');
                    
                    if (!bbttccControl) {
                        bbttccControl = {
                            name: 'bbttcc',
                            title: 'BBTTCC Controls',
                            icon: 'fas fa-shield-alt',
                            layer: 'TokenLayer',
                            tools: []
                        };
                        controls.push(bbttccControl);
                    }
                    
                    // Add dashboard tool if not exists
                    if (!bbttccControl.tools.find(t => t.name === 'dashboard')) {
                        bbttccControl.tools.push({
                            name: 'dashboard',
                            title: 'BBTTCC Dashboard',
                            icon: 'fas fa-chart-bar',
                            button: true,
                            onClick: () => {
                                if (window.BBTTCCGUI?.openDashboard) {
                                    window.BBTTCCGUI.openDashboard();
                                } else {
                                    ui.notifications.error("BBTTCC GUI system not loaded!");
                                }
                            }
                        });
                    }
                    
                    console.log(`${this.MODULE_ID} | Added dashboard button to Scene Controls via hook`);
                } catch (error) {
                    console.error(`${this.MODULE_ID} | Failed to add scene control:`, error);
                }
            });
            
            console.log(`${this.MODULE_ID} | Persistent GUI setup completed successfully`);
            
        } catch (error) {
            console.error(`${this.MODULE_ID} | Failed to setup persistent GUI:`, error);
        }
    }
    
    /**
     * Cleanup method for proper resource management
     */
    static cleanup() {
        // Clean up hooks
        this.hookIds.forEach(id => Hooks.off(id));
        this.hookIds = [];
        
        // Clear global references
        delete window.bbttccFactionsTest;
        
        // Reset state
        this.initialized = false;
        this.api = null;
        
        console.log(`${this.MODULE_ID} | Cleanup completed`);
    }
}

/**
 * Modern faction creation function with proper async/await patterns and error handling
 */
async function createFactionModern(factionData = {}) {
    const moduleId = BBTTCCFactionsModule.MODULE_ID;
    const startTime = performance.now();
    
    console.log(`${moduleId} | Starting modern faction creation...`);
    
    try {
        // Validation with proper error handling
        if (!game.ready) {
            throw new Error('Game not ready for faction creation');
        }
        
        if (!game.user.isGM) {
            const macroEnabled = game.settings.get(moduleId, 'enableMacroIntegration');
            if (!macroEnabled) {
                throw new Error('Only GMs can create factions when macro integration is disabled');
            }
        }
        
        // Input validation
        if (factionData.name && (typeof factionData.name !== 'string' || factionData.name.trim().length === 0)) {
            throw new Error('Faction name must be a non-empty string');
        }
        
        // Check for name conflicts
        const name = factionData.name || `New BBTTCC Faction ${Date.now()}`;
        const existingFaction = game.actors.find(actor => 
            actor.name.toLowerCase() === name.toLowerCase() && 
            actor.getFlag(moduleId, 'isFaction')
        );
        
        if (existingFaction) {
            throw new Error(`A faction named "${name}" already exists`);
        }
        
        // Prepare faction data with modern patterns
        const actorData = {
            name: name,
            type: "npc",
            system: {
                details: {
                    type: { value: "faction" },
                    biography: { value: factionData.biography || "" }
                }
            },
            flags: {
                [moduleId]: {
                    isFaction: true,
                    version: '4.8.1-ENHANCED',
                    createdAt: new Date().toISOString(),
                    createdBy: game.user.id,
                    ops: foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE),
                    warLog: [],
                    territories: [],
                    bases: []
                },
                core: {
                    sheetClass: "bbttcc-factions.FactionSheet"  // Confirmed working key format
                }
            }
        };
        
        console.log(`${moduleId} | Using sheet class:`, actorData.flags.core.sheetClass);
        console.log(`${moduleId} | Registered sheet key:`, BBTTCCFactionsModule.registeredSheetKey);
        
        // Merge with provided data safely
        const finalData = foundry.utils.mergeObject(actorData, factionData, { 
            inplace: false, 
            insertKeys: true, 
            insertValues: true 
        });
        
        // Ensure OPs structure is preserved
        finalData.flags[moduleId].ops = foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE);
        
        console.log(`${moduleId} | Creating faction with data:`, {
            name: finalData.name,
            hasOps: !!finalData.flags[moduleId].ops,
            opsKeys: Object.keys(finalData.flags[moduleId].ops)
        });
        
        // Create actor with timeout protection
        const faction = await Promise.race([
            Actor.create(finalData),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Faction creation timed out')), 30000)
            )
        ]);
        
        if (!faction) {
            throw new Error('Actor creation returned null');
        }
        
        // Verify faction was created properly
        const verifyOps = faction.getFlag(moduleId, 'ops');
        if (!verifyOps || Object.keys(verifyOps).length === 0) {
            console.warn(`${moduleId} | OPs missing after creation, fixing...`);
            await faction.setFlag(moduleId, 'ops', foundry.utils.deepClone(DEFAULT_OPS_STRUCTURE));
        }
        
        const endTime = performance.now();
        console.log(`${moduleId} | Faction created successfully in ${(endTime - startTime).toFixed(2)}ms:`, {
            name: faction.name,
            id: faction.id,
            hasOps: !!faction.getFlag(moduleId, 'ops')
        });
        
        // Success notification
        ui.notifications.info(`Faction "${faction.name}" created successfully!`);
        
        // Delayed sheet opening to prevent race conditions
        setTimeout(() => {
            try {
                faction.sheet?.render(true);
            } catch (sheetError) {
                console.warn(`${moduleId} | Could not open faction sheet:`, sheetError);
            }
        }, 500);
        
        return faction;
        
    } catch (error) {
        const endTime = performance.now();
        console.error(`${moduleId} | Faction creation failed after ${(endTime - startTime).toFixed(2)}ms:`, {
            error: error.message,
            stack: error.stack,
            factionData: factionData
        });
        
        ui.notifications.error(`Failed to create faction: ${error.message}`);
        throw error;
    }
}

/**
 * Initialize the module with modern patterns
 */
Hooks.once('init', async () => {
    console.log('BBTTCC Factions v4.8.1-ENHANCED | Starting initialization...');
    
    try {
        await BBTTCCFactionsModule.initialize();
    } catch (error) {
        console.error('BBTTCC Factions | Initialization failed:', error);
        ui.notifications.error('BBTTCC Factions failed to initialize. Check console for details.');
    }
});

/**
 * Final setup when game is ready
 */
Hooks.once('ready', () => {
    console.log('BBTTCC Factions | Ready hook fired, module fully operational');
    
    // Register sheets with delay to ensure D&D5e is fully ready
    setTimeout(() => {
        console.log('BBTTCC Factions | Registering sheets with delay...');
        console.log('BBTTCC Factions | CONFIG.Actor available:', !!CONFIG?.Actor?.sheetClasses?.npc);
        console.log('BBTTCC Factions | FactionSheet available:', typeof FactionSheet !== 'undefined');
        
        BBTTCCFactionsModule.registerSheets();
    }, 2000); // 2 second delay
    
    // Initialize integrated GUI system first
    setTimeout(() => {
        BBTTCCFactionsModule.initializeGUISystem();
    }, 2500); // 2.5 second delay
    
    // Setup persistent GUI buttons after everything is ready
    setTimeout(() => {
        BBTTCCFactionsModule.setupPersistentGUI();
    }, 3000); // 3 second delay to ensure GUI system is loaded
});

/**
 * Cleanup on module disable (good practice)
 */
Hooks.on('closeModule', (moduleId) => {
    if (moduleId === BBTTCCFactionsModule.MODULE_ID) {
        BBTTCCFactionsModule.cleanup();
    }
});

// Export for ES module compatibility
export { BBTTCCFactionsModule, createFactionModern, DEFAULT_OPS_STRUCTURE };